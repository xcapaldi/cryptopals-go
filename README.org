#+TITLE: cryptopals-go
#+AUTHOR: Xavier Capaldi

My solutions to the [[https://cryptopals.com/][Cryptopals Challenges]] in Go.

* Set 1: Basics
** 1. Convert hex to base64
Take a hex string as input and return it encoded into base64 (uint64).

#+BEGIN_SRC go :tangle 1-1.go
  package main

  import (
          "fmt"
          "encoding/hex"
          "encoding/base64"
          "log"
  )

  func convertHexToBase64(src string) (string, error) {
          // decode from hex
          b, err := hex.DecodeString(src)
          if err != nil {
                  return "", err
          }
          // encode to base64
          return base64.StdEncoding.EncodeToString(b), nil
  }

  func main() {
          src := "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"
          dst, err := convertHexToBase64(src)
          if err != nil {
                  log.Fatal(err)
          }
          fmt.Println("Base64 encoding:\n" , dst)
  }
#+END_SRC

#+RESULTS:
: Base64 encoding:
:  SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t

** 2. Fixed XOR
Given two equal-length hex strings, decode and perform XOR between the two.
Note that this could be made more efficient by perform the XOR operation on something larger than bytes (i.e. uint64s) but for these exercises performance is not an issue.

#+BEGIN_SRC go :tangle 1-2.go
  package main

  import (
          "fmt"
          "encoding/hex"
          "log"
  )

  func xorHexStrings(a, b string) ([]byte, error) {
          // decode from hex
          aDecoded, err := hex.DecodeString(a)
          if err != nil {
                  return nil, err
          }
          bDecoded, err := hex.DecodeString(b)
          if err != nil {
                  return nil, err
          }

          // check that strings are same length
          if len(aDecoded) != len(bDecoded) {
                  return nil, fmt.Errorf("hex strings are not equal length")
          }

          // XOR
          d := make([]byte, len(aDecoded))
          for i, _ := range d {
                  d[i] = aDecoded[i] ^ bDecoded[i]
          }

          return d, nil
  }

  func main() {
          a := "1c0111001f010100061a024b53535009181c"
          b := "686974207468652062756c6c277320657965"

          dst, err := xorHexStrings(a, b)
          if err != nil {
                  log.Fatal(err)
          }
          fmt.Printf("%x", dst)
  }
#+END_SRC

#+RESULTS:
: 746865206b696420646f6e277420706c6179

** 3. Single-byte XOR cipher
Given a hex-encoded string that has been XORed against a single character, find the key that was used and decrypt the message.
We are guaranteed that the original string was in plain English.

The solution works but I admit freely that it could return an invalid result given another input.
The method of "scoring" a deciphered result is crude.
I take the frequency of characters in the English alphabet as a float score value and sum the scores of all characters in a given deciphering attempt.
The highest scoring result is presented.
Rather than have duplicate values in the scoring map present for upper and lowercase characters, I simply adjust the uppercase characters before assigning the score of their lowercase counterpart.

#+BEGIN_SRC go :tangle 1-3.go
  package main

  import (
          "fmt"
          "encoding/hex"
          "log"
  )

  var englishCharFrequency = map[byte]float32 {
          97:8.34,    // a
          98:1.54,    // b
          99:2.73,    // c
          100:4.14,   // d
          101:12.60,  // e
          102:2.03,   // f
          103:1.92,   // g
          104:6.11,   // h
          105:6.71,   // i
          106:0.23,   // j
          107:0.87,   // k
          108:4.24,   // l
          109:2.53,   // m
          110:6.80,   // n
          111:7.70,   // o
          112:1.66,   // p
          113:0.09,   // q
          114:5.68,   // r
          115:6.11,   // s
          116:9.37,   // t
          117:2.85,   // u
          118:1.06,   // v
          119:2.34,   // w
          120:0.20,   // x
          121:2.04,   // y
          122:0.06,   // z
  }

  func decode(src string, scoringMap map[byte]float32) (key byte, decoded []byte, err error) {
          // decode from hex
          d, err := hex.DecodeString(src)
          if err != nil {
                  return byte(0), nil, err
          }
          decoded = make([]byte, len(d))
          var score float32
          // assume key is a single ascii character
          for k := 0; k < 126; k++ {
                  var keyScore float32
                  // inverse the xor with this key and sum the score
                  for i, _ := range d {
                          d[i] ^= byte(k)
                          if d[i] < 91 {
                                  // convert to lowercase for the purposes of scoring
                                  keyScore += scoringMap[d[i]+32]
                          } else {
                                  keyScore += scoringMap[d[i]]
                          }
                  }

                  // compare score with previous key
                  // if new score is higher replace the "best" key and decoding
                  if keyScore > score {
                          score = keyScore
                          key = byte(k)
                          copy(decoded, d)
                  }
          }

          return key, decoded, nil
  }

  func main() {
          src := "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"

          key, decoded, err := decode(src, englishCharFrequency)
          if err != nil {
                  log.Fatal(err)
          }

          fmt.Printf("key: %s\ndecoded message: %s\n", string([]byte{key}), string(decoded))
  }
#+END_SRC

#+RESULTS:
: key: X
: decoded message: Cooking MC's like a pound of bacon

** 4. Detect single-character XOR
Given an input [[https://cryptopals.com/static/challenge-data/4.txt][file]], check which 60-character string has been encrypted by single-character XOR.
Since the instructions were a little unclear, I first just printed the lines from the file decoded from hex.
I wanted to see if there were lines of English text and only one was encoded or if there were lines of gibberish and only one gibberish line could be decoded.
It seemed to be the latter.
The brute force approach is quite simple then.
If we make the same assumptions as 1-3, we can iterate through each line and iterate through every possible key to find the resulting decoded message with the highest value based letter frequency in the English language.
We should have a score associated with each line.
We can just assume the highest score is the "real" one and that message was encoded with single-character XOR.

#+BEGIN_SRC go :tangle 1-4.go
  package main

  import (
          "fmt"
          "log"
          "encoding/hex"
          "os"
          "bufio"
  )

  // englishCharFrequency holds the ascii (or utf-8)
  // byte value for lowercase letters in the English
  // language along with their corresponding percentage
  // frequency. To access the value of uppercase
  // characters, one can just modify the byte value.
  // Uppercase characters have values from 65 to 90.
  // Lowercase characters have value from 97 to 122.
  // All other values hold symbols that we wouldn't
  // want to modify. So to get the frequency of an
  // uppercase character, simply add 32 to the byte
  // value before looking up in the map.
  var englishCharFrequency = map[byte]float32 {
          97:8.34,    // a
          98:1.54,    // b
          99:2.73,    // c
          100:4.14,   // d
          101:12.60,  // e
          102:2.03,   // f
          103:1.92,   // g
          104:6.11,   // h
          105:6.71,   // i
          106:0.23,   // j
          107:0.87,   // k
          108:4.24,   // l
          109:2.53,   // m
          110:6.80,   // n
          111:7.70,   // o
          112:1.66,   // p
          113:0.09,   // q
          114:5.68,   // r
          115:6.11,   // s
          116:9.37,   // t
          117:2.85,   // u
          118:1.06,   // v
          119:2.34,   // w
          120:0.20,   // x
          121:2.04,   // y
          122:0.06,   // z
  }

  // readLines takes in a filepath and reads lines from it
  // one-by-one (appending to an output list) until it
  // reaches the end of the file. Before appending, each
  // line is decoded from hex into a byte slice for easy
  // operation later.
  func readLines(path string) (lines [][]byte, err error) {
          file, err := os.Open(path)
          if err != nil {
                  return nil, err
          }
          scanner := bufio.NewScanner(file)
          scanner.Split(bufio.ScanLines)
          for scanner.Scan() {
                  decodedLine, err := hex.DecodeString(scanner.Text())
                  if err != nil {
                          return nil, err
                  }
                  lines = append(lines, decodedLine)
          }
          if err = scanner.Err(); err != nil {
                  return nil, err
          }

          return lines, nil
  }

  // scoreLine iterates through every possible ascii character
  // and performs a single-char XOR operation on the input line.
  // For each key character used, it checks if the output has a
  // higher score (based on English character frequency) than the
  // previous best. Finally it returns the key and decoded line
  // with the highest value. We are more thorough than 1-3 and
  // actually check full range of possible keys.
  func scoreLine(line []byte, scoreMap map[byte]float32) (key byte, decoded []byte, score float32) {
          decoded = make([]byte, len(line))
          scratch := make([]byte, len(line))
          for k := 32; k < 127; k++ {
                  copy(scratch, line)
                  var kScore float32

                  // single-char XOR and sum score
                  for i, _ := range scratch {
                          scratch[i] ^= byte(k)
                          if ((scratch[i] > 64) && (scratch[i] < 91)) {
                                  // convert uppercase to lowercase
                                  kScore += scoreMap[scratch[i]+32]
                          } else {
                                  kScore += scoreMap[scratch[i]]
                          }
                  }

                  // compare score with previous key and supplant if higher
                  if kScore > score {
                          score = kScore
                          key = byte(k)
                          copy(decoded, scratch)
                  }
          }

          return key, decoded, score
          }


  // scoreLines scores each line by finding the single-char key
  // for XOR cipher that results in the highest scoring (based
  // on character frequency in English language).
  func scoreLines(lines [][]byte, scoreMap map[byte]float32) (bestKey byte, decoded []byte, linum int) {
          decoded = make([]byte, len(lines[0]))
          var bestScore float32

          for i, line := range lines {
                  key, scratch, score := scoreLine(line, scoreMap)
                  if score > bestScore {
                          bestScore = score
                          bestKey = key
                          copy(decoded, scratch)
                          linum = i
                  }

          }

          return

  }

  func main () {
          path := "4.txt"
          // read in the lines and decode from hex
          lines, err := readLines(path)
          if err != nil {
                  log.Fatal(err)
          }
          // score the lines finding the most likely
          // encoded
          bestKey, decoded, linum := scoreLines(lines, englishCharFrequency)
          fmt.Printf("line %v was encoding via single-character XOR cipher with %s as the key. The decoded line is: %s\n", linum, string([]byte{bestKey}), string(decoded))
  }
#+END_SRC

#+RESULTS:
: line 170 was encoding via single-character XOR cipher with 5 as the key. The decoded line is: Now that the party is jumping

** 5. Implement repeating-key XOR
Repeating-key XOR simply iterates between the bytes of the key as is performs the XOR encryption.
If the key has five bytes, it will iterate between those five bytes for each set of five source bytes.
Implementing the encryption is straightforward.

#+BEGIN_SRC go :tangle 1-5.go
  package main

  import (
          "fmt"
  )

  func encrypt(src []byte, key []byte) {
          for i, _ := range src {
                  src[i] ^= key[i%len(key)]
          }
  }

  func main() {
          src := "Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal"
          bSrc := []byte(src)
          key := "ICE"

          encrypt(bSrc, []byte(key))
          fmt.Printf("%x", bSrc)
  }
#+END_SRC

#+RESULTS:
: 0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f

** 6. Break repeating-key XOR
First we need to write a method that can compute the Hamming distance between two strings.
The Hamming distance is the number of differing bits.
We can find this by counting the number of set bits after XORing the two strings.
This can be done manually by shifting a mask and checking in bit in each byte.
Alternatively, we can use the ~math/bits~ bit counting methods.

#+BEGIN_SRC go
  package main

  import (
          "fmt"
          "log"
          "math/bits"
  )

  func hammingDist(strOne, strTwo []byte) (dist int, err error) {
          if len(strOne) != len(strTwo) {
                  return dist, fmt.Errorf("hamming distance can not be calculated for strings of differing length")
          }

          var scratch byte
          for i, _ := range strOne {
                  scratch = strOne[i] ^ strTwo[i]
                  for j := 0; j < 8; j++ {
                          if scratch & (1 << j) > 0 {
                                  dist++
                          }
                  }
          }

          return dist, nil	
  }

  func hammingDistWithMathBits(strOne, strTwo []byte) (dist int, err error) {
          if len(strOne) != len(strTwo) {
                  return dist, fmt.Errorf("hamming distance can not be calculated for strings of differing length")
          }
          for i, _ := range strOne {
                  dist += bits.OnesCount8(strOne[i] ^ strTwo[i])
          }

          return dist, nil	
  }

  func main() {
          strOne := "this is a test"
          strTwo := "wokka wokka!!!"
          hDist, err := hammingDist([]byte(strOne), []byte(strTwo))
          if err != nil {
                  log.Fatal(err)
          }
          fmt.Println("hamming distance:", hDist)
	
          hDist, err = hammingDistWithMathBits([]byte(strOne), []byte(strTwo))
          if err != nil {
                  log.Fatal(err)
          }
          fmt.Println("hamming distance:", hDist)
  }
#+END_SRC

#+RESULTS:
: hamming distance: 37
: hamming distance: 37

Still unfinished . . .

** 7. AES in ECB mode
** 8. Detect AES in ECB mode

* Set 2: Block crypto
* Set 3: Block & stream crypto
* Set 4: Stream crypto and randomness
* Set 5: Diffie-Hellman and friends
* Set 6: RSA and DSA
* Set 7: Hashes
* Set 8: Abstract algebra
